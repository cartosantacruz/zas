let map;
let obrasGeoJSON; // Para almacenar los datos y usarlos en análisis [1, 2, 6]
let currentAnalysisLayer; // Referencia a la capa de análisis actual para poder eliminarla

// Inicialización del mapa
function initMap() {
    map = L.map('mapa').setView([-49.3, -69.2], 5); 

    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
    }).addTo(map);

    cargarDatosObras(); 
}

/**
 * Carga los datos GeoJSON del archivo local.
 * AJUSTE CRUCIAL DE RUTA.
 */
function cargarDatosObras() {
    console.log("Cargando datos de obras...");
    
    // **MODIFICACIÓN APLICADA:** Ruta ajustada para la estructura de carpetas: data/obras.geojson
    const geojsonURL = 'data/obras.geojson';

    fetch(geojsonURL)
        .then(response => {
            if (!response.ok) {
                // Reporte de error similar a la lógica de manejo de errores [7]
                throw new Error(`Error HTTP: ${response.status}`);
            }
            return response.json();
        })
        .then(data => {
            console.log("Datos de obras cargados exitosamente.");
            obrasGeoJSON = data; 
            
            // Actualización del resumen general
            const totalObras = data.features.length;
            document.getElementById('resumen-general').innerHTML = `
                <h4>Resumen General</h4>
                <p>Total de obras registradas: ${totalObras}</p>
            `;

            // Adición de la capa de obras al mapa
            L.geoJSON(data, {
                onEachFeature: function (feature, layer) {
                    // Adición de popup [3]
                    layer.bindPopup('<b>Obra:</b> ' + feature.properties.nombre_obra || 'Sin nombre'); 
                }
            }).addTo(map);

        })
        .catch(error => {
            console.error("Error al cargar los datos.", error); 
            document.getElementById('resumen-general').innerHTML = `
                <h4>Resumen General</h4>
                <p style="color: red;">Error al cargar los datos: ${error.message}.</p>
            `; 
        });
}

/**
 * Función principal para ejecutar el análisis espacial seleccionado [2].
 */
function runSpatialAnalysis() {
    if (!obrasGeoJSON) {
        alert('Aún no se han cargado los datos de obras.');
        return;
    }

    // Limpia capas de análisis previas
    if (currentAnalysisLayer) {
        map.removeLayer(currentAnalysisLayer);
    }

    const selectedAnalysis = document.getElementById('analisis-type-select').value;
    const resultContainer = document.getElementById('resultados-analisis');

    // Estructura de control basada en switch [2]
    switch (selectedAnalysis) {
        case 'density':
            // Esta lógica requeriría datos de distritos [6] y la definición de la leyenda [4].
            resultContainer.innerHTML = "<p>Iniciando Análisis de Densidad (Requiere datos de distritos)...</p>";
            break;
        case 'zones':
            createBuffers(obrasGeoJSON, resultContainer); // Lógica de Buffer [1, 3]
            break;
        case 'heatmap':
            createHeatmap(obrasGeoJSON, resultContainer); // Lógica de Mapa de Calor [2, 5]
            break;
        default:
            resultContainer.innerHTML = "<p>Seleccione un tipo de análisis válido.</p>";
    }
}

/**
 * Crea Zonas de Influencia (Buffers) alrededor de los puntos de las obras [1].
 */
function createBuffers(data, resultContainer) {
    const pointData = data; 
    const bufferDistance = 0.5; // 0.5 km por defecto [1]
    const options = { steps: 32, units: 'kilometers' };

    let buffers = [];
    
    // Recorrer puntos y crear buffers usando Turf.js [1]
    pointData.features.forEach(feature => {
        const buffer = turf.buffer(feature.geometry, bufferDistance, options);
        buffers.push(buffer);
    });

    const bufferCollection = turf.featureCollection(buffers);
    
    const analysisLayer = L.geoJSON(bufferCollection, {
        style: { color: 'blue', weight: 1, opacity: 0.5, fillColor: 'blue', fillOpacity: 0.2 },
        // Uso de onEachFeature para añadir popups con la información del buffer [3]
        onEachFeature: function (feature, layer) {
            layer.bindPopup(`
                <div><b>Área de Influencia</b></div>
                <div>Radio: ${bufferDistance} m</div>`
            ); 
        }
    });

    analysisLayer.addTo(map);
    currentAnalysisLayer = analysisLayer;

    // Mostrar resultados [3]
    resultContainer.innerHTML = `
        <h4>Análisis de Áreas de Influencia</h4>
        <p>Se han generado áreas de influencia de <b>${bufferDistance} km</b>.</p>
    `;
}

/**
 * Crea un Mapa de Calor basado en los puntos de las obras [2, 5].
 */
function createHeatmap(data, resultContainer) {
    const pointData = data; 
    let heatData = [];

    // Preparar los datos (coordenadas e intensidad) [2, 5]
    pointData.features.forEach(fixture => {
        const coords = fixture.geometry.coordinates;
        // Asume que existe una propiedad 'visitas' y la divide entre 1000 para intensidad [5]
        const intensity = (fixture.properties.visitas || 1) / 1000; 

        // Leaflet.heat requiere [latitud, longitud, intensidad] [5]
        heatData.push([coords[6], coords, intensity]); 
    });

    // Creación de la capa de mapa de calor [5]
    const analysisLayer = L.heatLayer(heatData, {
        radius: 25, 
        blur: 17,   
        maxZoom: 17, 
        gradient: { // Definición de gradiente de color [5]
            0.0: 'blue',
            0.5: 'lime',
            1.0: 'red'
        }
    });

    analysisLayer.addTo(map); // Adicionar al mapa [5]
    currentAnalysisLayer = analysisLayer;

    resultContainer.innerHTML = `
        <h4>Análisis de Mapa de Calor</h4>
        <p>Mapa de calor generado basado en la intensidad de las obras.</p>
    `;
}

// Inicia la aplicación al cargar el DOM [8]
document.addEventListener('DOMContentLoaded', initMap);